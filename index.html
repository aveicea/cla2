<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Î©ÄÌã∞ Ï∫òÎ¶∞Îçî Î∑∞Ïñ¥</title>
<style>
/* CSS Ïä§ÌÉÄÏùº - ÏõêÎ≥∏ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ */
:root {
  --accent-color: #D1D1D1;
  --accent-hover-color: #3367d6;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f5f5f5;
  color: #333;
  height: 100vh;
  overflow: hidden;
}

.header {
  background: white;
  padding: 15px 20px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.view-selector {
  display: flex;
  gap: 5px;
}

.view-btn {
  background: #f8f9fa;
  border: 1px solid #e0e0e0;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}

.view-btn:hover {
  background-color: var(--accent-hover-color);
  color: white;
  border-color: var(--accent-hover-color);
}

.view-btn.active {
  background-color: var(--accent-color);
  color: white;
  border-color: var(--accent-color);
}

.nav-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.nav-btn {
  background: white;
  border: 1px solid #e0e0e0;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background-color: var(--accent-hover-color);
  color: white;
  border-color: var(--accent-hover-color);
}

.current-date {
  font-weight: bold;
  font-size: 18px;
  min-width: 200px;
  text-align: center;
}

.settings-btn {
  background: var(--accent-color);
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s ease;
}

.settings-btn:hover {
  background-color: var(--accent-hover-color);
}

.settings-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 400px;
  height: 100vh;
  background: white;
  box-shadow: -2px 0 10px rgba(0,0,0,0.3);
  transition: right 0.3s ease;
  z-index: 1000;
  overflow-y: auto;
  padding: 20px;
}

.settings-panel[style*="block"] {
  right: 0;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  z-index: 999;
  display: none;
}

.settings-title {
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
  border-bottom: 2px solid var(--accent-color);
  padding-bottom: 10px;
}

.toggle-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  padding: 12px 0;
  border-bottom: 1px solid #e0e0e0;
  margin-bottom: 10px;
}

.toggle-header:hover {
  background-color: #f8f9fa;
}

.color-picker-title {
  font-weight: 600;
  color: #333;
}

.toggle-icon {
  font-size: 16px;
  transition: transform 0.3s ease;
}

.toggle-icon.expanded {
  transform: rotate(180deg);
}

.toggle-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  margin-bottom: 15px;
}

.toggle-content.expanded {
  max-height: 500px;
}

.color-input-row {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.color-picker-input {
  width: 50px;
  height: 35px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  cursor: pointer;
}

.color-text-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  font-size: 14px;
}

.preset-colors {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 8px;
}

.preset-color {
  width: 35px;
  height: 35px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: transform 0.2s ease;
}

.preset-color:hover {
  transform: scale(1.1);
  border-color: #666;
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: #333;
}

.input-group input, .input-group select, .input-group textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  font-size: 14px;
}

.help-text {
  font-size: 12px;
  color: #666;
  margin-top: 5px;
  line-height: 1.4;
}

.calendar-inputs {
  display: none;
}

.calendar-inputs.active {
  display: block;
}

.btn {
  padding: 10px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
}

.btn-primary {
  background: var(--accent-color);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover-color);
}

.btn-secondary {
  background: #f8f9fa;
  color: #333;
  border: 1px solid #e0e0e0;
}

.btn-secondary:hover {
  background: #e9ecef;
}

.calendar-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: white;
  transition: all 0.2s ease;
}

.calendar-item:hover {
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.calendar-item.active {
  border-color: var(--accent-color);
  background-color: #f8f9ff;
}

.calendar-color-picker {
  width: 30px;
  height: 30px;
  border: none;
  border-radius: 50%;
  cursor: pointer;
}

.calendar-info {
  flex: 1;
}

.calendar-name {
  font-weight: 600;
  font-size: 14px;
  border: none;
  background: transparent;
  color: #333;
  margin-bottom: 2px;
}

.calendar-url {
  font-size: 12px;
  color: #666;
  margin-bottom: 2px;
}

.calendar-status {
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 600;
}

.calendar-status.success {
  background: #d4edda;
  color: #155724;
}

.calendar-status.loading {
  background: #fff3cd;
  color: #856404;
}

.calendar-status.error {
  background: #f8d7da;
  color: #721c24;
}

.calendar-actions {
  display: flex;
  gap: 5px;
}

.toggle-btn {
  background: none;
  border: 1px solid #e0e0e0;
  padding: 5px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

.toggle-btn:hover {
  background: #f8f9fa;
}

.remove-btn:hover {
  background: #f8d7da;
  color: #721c24;
}

.view-calendar-section {
  margin-bottom: 15px;
}

.view-calendar-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  margin-bottom: 8px;
}

.view-calendar-item {
  display: flex;
  align-items: center;
  font-size: 13px;
  cursor: pointer;
}

.debug-log {
  max-height: 200px;
  overflow-y: auto;
  background: #f8f9fa;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  padding: 10px;
  font-family: monospace;
  font-size: 12px;
  margin-top: 10px;
}

.debug-log div {
  margin-bottom: 2px;
  padding: 2px 0;
  border-bottom: 1px solid #eee;
}

.calendar-container {
  flex: 1;
  overflow: auto;
  height: calc(100vh - 80px);
}

.calendar-content {
  padding: 20px;
}

.loading {
  text-align: center;
  padding: 50px;
  font-size: 18px;
  color: #666;
}

/* Ï∫òÎ¶∞Îçî Î∑∞ Ïä§ÌÉÄÏùº */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 1px;
  background: #e0e0e0;
  border: 1px solid #e0e0e0;
}

.calendar-grid.month-view {
  grid-template-rows: 40px repeat(6, 1fr);
  height: 600px;
}

.week-header {
  background: #f8f9fa;
  padding: 10px;
  text-align: center;
  font-weight: bold;
  font-size: 14px;
  border-right: 1px solid #e0e0e0;
}

.calendar-day {
  background: white;
  padding: 8px;
  min-height: 100px;
  position: relative;
}

.calendar-day.today {
  background: var(--accent-color);
  color: white;
}

.calendar-day.other-month {
  background: #f8f9fa;
  color: #999;
}

.day-number {
  font-weight: bold;
  margin-bottom: 5px;
}

.event {
  background: #4285f4;
  color: white;
  padding: 2px 4px;
  margin: 1px 0;
  border-radius: 3px;
  font-size: 11px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: pointer;
}

.time-based-view {
  background: white;
  border: 1px solid #e0e0e0;
}

.time-slot {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #666;
}

.day-cell {
  border-right: 1px solid #e0e0e0;
  border-bottom: 1px solid #e0e0e0;
  min-height: 25px;
}

.all-day-event {
  font-weight: 500;
  z-index: 10;
}

.time-event {
  font-weight: 500;
  border-left: 3px solid rgba(255,255,255,0.3);
}
</style>
</head>
<body>
<div class="header">
  <div class="view-selector">
    <button class="view-btn active" onclick="setView('day')" id="dayBtn">Ïùº</button>
    <button class="view-btn" onclick="setView('week')" id="weekBtn">Ï£º</button>
    <button class="view-btn" onclick="setView('month')" id="monthBtn">Ïõî</button>
  </div>
  
  <div class="nav-controls">
    <button class="nav-btn" onclick="navigateCalendar(-1)">‚Äπ</button>
    <div class="current-date" id="currentDate"></div>
    <button class="nav-btn" onclick="navigateCalendar(1)">‚Ä∫</button>
    <button class="nav-btn" onclick="goToToday()">üìÖ</button>
  </div>
  
  <button class="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>
  
  <div class="settings-panel" id="settingsPanel">
    <div class="settings-title">Î©ÄÌã∞ Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï</div>

<!-- Î∑∞Î≥Ñ Ï∫òÎ¶∞Îçî ÏÑ†ÌÉù -->
<div class="view-calendar-section">
  <div class="toggle-header" onclick="toggleSection('viewCalendarSettings', 'viewToggleIcon')">
    <div class="color-picker-title">Î∑∞Î≥Ñ Ï∫òÎ¶∞Îçî ÏÑ†ÌÉù</div>
    <div class="toggle-icon" id="viewToggleIcon">‚ñº</div>
  </div>
  <div class="toggle-content" id="viewCalendarSettings">
    <!-- ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê® -->
  </div>
</div>

<!-- ÌÖåÎßà ÏÉâÏÉÅ -->
<div class="color-picker-group">
  <div class="toggle-header" onclick="toggleSection('themeColorContent', 'themeToggleIcon')">
    <div class="color-picker-title">ÌÖåÎßà ÏÉâÏÉÅ</div>
    <div class="toggle-icon" id="themeToggleIcon">‚ñº</div>
  </div>
  <div class="toggle-content" id="themeColorContent">
    <div class="color-input-row">
      <input type="color" class="color-picker-input" id="colorPicker" onchange="updateColorFromPicker()">
      <input type="text" class="color-text-input" id="colorText" placeholder="#D1D1D1" oninput="updateColorFromText()" maxlength="7">
    </div>
    <div class="preset-colors">
      <div class="preset-color" style="background-color: #4285f4;" onclick="setPresetColor('#4285f4')"></div>
      <div class="preset-color" style="background-color: #34a853;" onclick="setPresetColor('#34a853')"></div>
      <div class="preset-color" style="background-color: #ea4335;" onclick="setPresetColor('#ea4335')"></div>
      <div class="preset-color" style="background-color: #ffc107;" onclick="setPresetColor('#ffc107')"></div>
      <div class="preset-color" style="background-color: #9c27b0;" onclick="setPresetColor('#9c27b0')"></div>
      <div class="preset-color" style="background-color: #607d8b;" onclick="setPresetColor('#607d8b')"></div>
    </div>
  </div>
</div>

<!-- Ïó∞ÎèôÎêú Ï∫òÎ¶∞Îçî Î™©Î°ù -->
<div class="calendar-list-section">
  <div class="toggle-header" onclick="toggleSection('calendarListContent', 'listToggleIcon')">
    <div class="color-picker-title">Ïó∞ÎèôÎêú Ï∫òÎ¶∞Îçî Î™©Î°ù</div>
    <div style="display: flex; align-items: center; gap: 8px;">
      <button class="nav-btn" onclick="refreshAllCalendars()" title="Î™®Îì† Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ®">üîÑ</button>
      <div class="toggle-icon" id="listToggleIcon">‚ñº</div>
    </div>
  </div>
  <div class="toggle-content" id="calendarListContent">
    <div id="calendarList">
      <p style="color: #666; font-size: 12px; text-align: center; padding: 20px;">
        Ïó∞ÎèôÎêú Ï∫òÎ¶∞ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.<br>ÏïÑÎûòÏóêÏÑú Ï∫òÎ¶∞ÎçîÎ•º Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî!
      </p>
    </div>
  </div>
</div>

<!-- Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä -->
<div class="add-calendar-section">
  <div class="toggle-header" onclick="toggleSection('addCalendarContent', 'addToggleIcon')">
    <div class="color-picker-title">Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä</div>
    <div class="toggle-icon" id="addToggleIcon">‚ñº</div>
  </div>
  <div class="toggle-content" id="addCalendarContent">
    <div class="input-group">
      <label>Ï∫òÎ¶∞Îçî Ïú†Ìòï</label>
      <select id="calendarType" onchange="updateCalendarInputs()">
        <option value="ical">iCal ÎßÅÌÅ¨ (.ics)</option>
        <option value="googlePublic">Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Í≥µÍ∞ú ÎßÅÌÅ¨</option>
        <option value="api">Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî API</option>
      </select>
    </div>
    
    <div class="input-group">
      <label>Ï∫òÎ¶∞Îçî Ïù¥Î¶Ñ</label>
      <input type="text" id="calendarName" placeholder="Ïòà: Í∞úÏù∏ ÏùºÏ†ï, ÏóÖÎ¨¥ Ï∫òÎ¶∞Îçî">
    </div>
    
    <div class="input-group">
      <label>Ï∫òÎ¶∞Îçî ÏÉâÏÉÅ</label>
      <input type="color" id="calendarColor" value="#D1D1D1">
    </div>
    
    <div id="icalInputs" class="calendar-inputs active">
      <div class="input-group">
        <label>iCal ÎßÅÌÅ¨</label>
        <textarea id="icalUrl" rows="3" placeholder="https://calendar.google.com/calendar/ical/.../basic.ics"></textarea>
        <div class="help-text">
          Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï ‚Üí ÌÜµÌï© Î∞è Í≥µÏú† ‚Üí ÎπÑÍ≥µÍ∞ú Ï£ºÏÜåÏùò iCal ÎßÅÌÅ¨Î•º Î≥µÏÇ¨ÌïòÏÑ∏Ïöî.
        </div>
      </div>
    </div>
    
    <div id="googlePublicInputs" class="calendar-inputs">
      <div class="input-group">
        <label>Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî ID</label>
        <input type="text" id="googleCalendarId" placeholder="Ï∫òÎ¶∞ÎçîID@group.calendar.google.com">
        <div class="help-text">
          Í≥µÍ∞úÎêú Íµ¨Í∏Ä Ï∫òÎ¶∞ÎçîÏùò Ï∫òÎ¶∞Îçî IDÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.<br>
          Ïòà: ko.south_korea#holiday@group.v.calendar.google.com (ÌïúÍµ≠ Í≥µÌú¥Ïùº)
        </div>
      </div>
    </div>
    
    <div id="apiInputs" class="calendar-inputs">
      <div class="input-group">
        <label>API ÌÇ§</label>
        <input type="text" id="apiKey" placeholder="Google Calendar API ÌÇ§">
      </div>
      <div class="input-group">
        <label>Ï∫òÎ¶∞Îçî ID</label>
        <input type="text" id="calendarId" placeholder="primary ÎòêÎäî Ïù¥Î©îÏùº@gmail.com">
      </div>
    </div>
    
    <button class="btn btn-primary" onclick="addCalendar()">Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä</button>
  </div>
</div>

    <div class="backup-section">
      <div class="color-picker-title">ÏÑ§Ï†ï Î∞±ÏóÖ/Î≥µÏõê</div>
      <div style="display: flex; gap: 8px; margin-bottom: 10px;">
        <button class="btn btn-primary" onclick="exportCalendarSettings()">ÏÑ§Ï†ï ÎÇ¥Î†§Î∞õÍ∏∞</button>
        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">ÏÑ§Ï†ï Í∞ÄÏ†∏Ïò§Í∏∞</button>
      </div>
      <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importCalendarSettings(this)">
      <div style="font-size: 11px; color: #666; margin-top: 5px;">
        Ï∫òÎ¶∞Îçî Ïó∞Îèô Ï†ïÎ≥¥, ÏÉâÏÉÅ, Î∑∞ ÏÑ§Ï†ï Îì±ÏùÑ Î∞±ÏóÖÌïòÍ≥† Î≥µÏõêÌï† Ïàò ÏûàÏäµÎãàÎã§.
      </div>
    </div>
    
    <div class="debug-section">
      <div class="color-picker-title">ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥</div>
      <button class="btn btn-secondary" onclick="clearDebugLog()">Î°úÍ∑∏ ÏßÄÏö∞Í∏∞</button>
      <div id="debugLog" class="debug-log"></div>
    </div>
  </div>
</div>

<div class="overlay" id="overlay" onclick="closeSettings()"></div>

<div class="calendar-container">
  <div class="calendar-content" id="calendarContent">
    <div class="loading">Ï∫òÎ¶∞ÎçîÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
  </div>
</div>

<script>
  // ================================================================================
  // Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ†Ïñ∏
  // ================================================================================
  
  let currentView = 'day';
  let currentDate = new Date();
  let accentColor = '#D1D1D1';
  let accentHoverColor = '#3367d6';
  let calendars = [];
  let debugMessages = [];
  let viewCalendarSettings = {
    day: [],
    week: [],
    month: []
  };
  
  // ÏÉÅÏàò Ï†ïÏùò
  const calendarColors = ['#4285f4', '#34a853', '#ea4335', '#ffc107', '#9c27b0', '#607d8b'];
  const SLOT_START_HOUR = 6;
  const TOTAL_HOURS = 24;
  const SLOT_COUNT = TOTAL_HOURS;
  const weekdays = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
  
  // DOM ÏöîÏÜå Ï∞∏Ï°∞
  const settingsPanel = document.getElementById("settingsPanel");
  const overlay = document.getElementById("overlay");
  const colorPicker = document.getElementById("colorPicker");
  const colorText = document.getElementById("colorText");
  const currentDateElement = document.getElementById("currentDate");
  const calendarContent = document.getElementById("calendarContent");
  const calendarList = document.getElementById("calendarList");
  const debugLog = document.getElementById("debugLog");
  
  // ================================================================================
  // Ï¥àÍ∏∞Ìôî Î∞è ÏÑ§Ï†ï Í¥ÄÎ¶¨
  // ================================================================================
  
  function init() {
    loadFromStorage();
    updateCurrentDateDisplay();
    setAccentColor(accentColor);
    updateCalendarList();
    renderCalendar();
    addDebugLog('ÏÉòÌîå Ï∫òÎ¶∞ÎçîÍ∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.');
    addDebugLog('Ï∫òÎ¶∞Îçî Î∑∞Ïñ¥Í∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.');
    
    // 2Î∂ÑÎßàÎã§ Ï∫òÎ¶∞Îçî ÏûêÎèô ÏÉàÎ°úÍ≥†Ïπ®
    setInterval(async () => {
      for (const calendar of calendars) {
        if (calendar.type !== 'sample' && calendar.visible) {
          try {
            const oldEventCount = calendar.events.length;
            await loadCalendarEvents(calendar);
            if (calendar.events.length !== oldEventCount) {
              renderCalendar();
              addDebugLog(`ÏÉà ÏùºÏ†ï Í∞êÏßÄ: ${calendar.name}`);
            }
          } catch (error) {
            // Ï°∞Ïö©Ìûà Ïã§Ìå® Ï≤òÎ¶¨
          }
        }
      }
    }, 120000);
    
    initEventListeners();
  }
  
  function initEventListeners() {
    // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
    document.addEventListener('keydown', handleKeydown);
    
    // Ï∫òÎ¶∞Îçî ÏÉâÏÉÅ ÏûêÎèô Ìï†Îãπ
    const calendarColorInput = document.getElementById('calendarColor');
    if (calendarColorInput) {
      calendarColorInput.addEventListener('focus', function() {
        this.value = calendarColors[calendars.length % calendarColors.length];
      });
    }
  }
  
  function handleKeydown(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.key) {
      case 'ArrowLeft':
        navigateCalendar(-1);
        e.preventDefault();
        break;
      case 'ArrowRight':
        navigateCalendar(1);
        e.preventDefault();
        break;
      case 't':
      case 'T':
        goToToday();
        break;
      case 'm':
      case 'M':
        setView('month');
        break;
      case 'w':
      case 'W':
        setView('week');
        break;
      case 'd':
      case 'D':
        setView('day');
        break;
      case 'Escape':
        closeSettings();
        break;
    }
  }
  
  // ================================================================================
  // ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ ÏãúÏä§ÌÖú
  // ================================================================================
  
  function addDebugLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    debugMessages.push(`[${timestamp}] ${message}`);
    if (debugMessages.length > 50) debugMessages.shift();
    
    if (debugLog) {
      debugLog.innerHTML = debugMessages.map(msg => `<div>${msg}</div>`).join('');
      debugLog.scrollTop = debugLog.scrollHeight;
    }
    console.log(message);
  }
  
  function clearDebugLog() {
    debugMessages = [];
    if (debugLog) {
      debugLog.innerHTML = '';
    }
  }
  
  // ================================================================================
  // UI Ïª®Ìä∏Î°§ Ìï®ÏàòÎì§
  // ================================================================================
  
  function toggleSettings() {
    const isVisible = settingsPanel.style.display === 'block';
    if (isVisible) {
      closeSettings();
    } else {
      openSettings();
    }
  }
  
  function openSettings() {
    settingsPanel.style.display = 'block';
    overlay.style.display = 'block';
    
    // ÏÑ§Ï†ï Ìå®ÎÑêÏóê Ïä§ÌÅ¨Î°§ Í∏∞Îä• Ï∂îÍ∞Ä
    settingsPanel.style.maxHeight = '90vh';
    settingsPanel.style.overflowY = 'auto';
  }
  
  function closeSettings() {
    settingsPanel.style.display = 'none';
    overlay.style.display = 'none';
  }
  
  function toggleSection(contentId, iconId) {
    const content = document.getElementById(contentId);
    const icon = document.getElementById(iconId);
    
    content.classList.toggle('expanded');
    icon.classList.toggle('expanded');
  }
  
  // ================================================================================
  // Î∑∞ Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
  // ================================================================================
  
  function setView(viewMode) {
    currentView = viewMode;
    document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(viewMode + 'Btn').classList.add('active');
    updateCurrentDateDisplay();
    renderCalendar();
    saveToStorage();
  }
  
  function navigateCalendar(direction) {
    if (currentView === 'month') {
      currentDate.setMonth(currentDate.getMonth() + direction);
    } else if (currentView === 'week') {
      currentDate.setDate(currentDate.getDate() + (direction * 7));
    } else if (currentView === 'day') {
      currentDate.setDate(currentDate.getDate() + direction);
    }
    updateCurrentDateDisplay();
    renderCalendar();
  }
  
  function goToToday() {
    currentDate = new Date();
    updateCurrentDateDisplay();
    renderCalendar();
  }
  
  function updateCurrentDateDisplay() {
    const options = currentView === 'day' 
      ? { month: 'long', day: 'numeric', weekday: 'short' }
      : { year: 'numeric', month: 'long' };
      
    let formatted = currentDate.toLocaleDateString('ko-KR', options);
    
    if (currentView === 'day') {
      formatted = formatted.replace(/(\d+Ïùº)\s*(\([^)]+\))/, '$1 $2');
    }
    
    currentDateElement.textContent = formatted;
  }
  
  // ================================================================================
  // ÏÉâÏÉÅ Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
  // ================================================================================
  
  function darkenColor(hex, percent) {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, Math.min(255, (num >> 16) - amt));
    const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) - amt));
    const B = Math.max(0, Math.min(255, (num & 0x0000FF) - amt));
    
    return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
  }
  
  function setAccentColor(color) {
    accentColor = color;
    accentHoverColor = darkenColor(color, 15);
    
    document.documentElement.style.setProperty('--accent-color', color);
    document.documentElement.style.setProperty('--accent-hover-color', accentHoverColor);
    
    if (colorPicker) colorPicker.value = color;
    if (colorText) colorText.value = color.toUpperCase();
    
    saveToStorage();
  }
  
  function setPresetColor(color) {
    setAccentColor(color);
  }
  
  function updateColorFromPicker() {
    setAccentColor(colorPicker.value);
  }
  
  function updateColorFromText() {
    let color = colorText.value.trim();
    if (!color.startsWith('#')) color = '#' + color;
    if (/^#[0-9A-F]{6}$/i.test(color)) {
      setAccentColor(color);
    }
  }
  
  // ================================================================================
  // Ï∫òÎ¶∞Îçî ÏûÖÎ†• Ìèº Í¥ÄÎ¶¨
  // ================================================================================
  
  function updateCalendarInputs() {
    const type = document.getElementById('calendarType').value;
    
    document.querySelectorAll('.calendar-inputs').forEach(input => {
      input.classList.remove('active');
    });
    
    document.getElementById(type + 'Inputs').classList.add('active');
  }
  
  // ================================================================================
  // Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏ Î°úÎî© Ìï®ÏàòÎì§
  // ================================================================================
  
  async function loadCalendarEvents(calendar) {
    addDebugLog(`Ïù¥Î≤§Ìä∏ Î°úÎìú ÏãúÏûë: ${calendar.name} (${calendar.type})`);
    
    switch (calendar.type) {
      case 'ical':
        await loadIcalEvents(calendar);
        break;
      case 'googlePublic':
        await loadGooglePublicEvents(calendar);
        break;
      case 'api':
        await loadApiEvents(calendar);
        break;
      case 'sample':
        calendar.events = generateSampleEvents();
        break;
    }
  }
  
  async function loadIcalEvents(calendar) {
    const proxies = [
      `https://api.allorigins.win/get?url=${encodeURIComponent(calendar.url)}`,
      `https://cors-anywhere.herokuapp.com/${calendar.url}`,
      `https://corsproxy.io/?${encodeURIComponent(calendar.url)}`,
      `https://proxy.cors.sh/${calendar.url}`,
      `https://cors.sh/${calendar.url}`,
      `https://thingproxy.freeboard.io/fetch/${calendar.url}`,
      `https://yacdn.org/proxy/${calendar.url}`
    ];
    
    let lastError = null;
    
    for (const proxyUrl of proxies) {
      try {
        addDebugLog(`ÌîÑÎ°ùÏãú ÏãúÎèÑ: ${proxyUrl.includes('allorigins') ? 'AllOrigins' : proxyUrl.split('/')[2]}`);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        
        const response = await fetch(proxyUrl, {
          method: 'GET',
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/calendar,text/plain,*/*',
            'Cache-Control': 'no-cache'
          },
          signal: controller.signal,
          mode: 'cors'
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        let icalData;
        if (proxyUrl.includes('allorigins')) {
          const data = await response.json();
          icalData = data.contents;
        } else {
          icalData = await response.text();
        }
        
        if (!icalData || typeof icalData !== 'string' || 
            (!icalData.includes('BEGIN:VCALENDAR') && !icalData.includes('BEGIN:VEVENT'))) {
          throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ iCal Îç∞Ïù¥ÌÑ∞');
        }
        
        calendar.events = parseIcalData(icalData);
        addDebugLog(`iCal ÌååÏã± ÏôÑÎ£å: ${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
        return;
        
      } catch (error) {
        lastError = error;
        addDebugLog(`ÌîÑÎ°ùÏãú Ïã§Ìå®: ${proxyUrl.split('/')[2]} - ${error.message}`);
        continue;
      }
    }
    
    throw new Error(`Î™®Îì† ÌîÑÎ°ùÏãú Ïã§Ìå®. ÎßàÏßÄÎßâ Ïò§Î•ò: ${lastError.message}\n\nÌï¥Í≤∞Î∞©Î≤ï:\n1. Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Í≥µÍ∞ú ÏÑ§Ï†ï ÌôïÏù∏\n2. iCal ÎßÅÌÅ¨Í∞Ä Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏\n3. Îã§Î•∏ Ï∫òÎ¶∞Îçî ÏÑúÎπÑÏä§ Ïù¥Ïö© Í≥†Î†§`);
  }
  
  async function loadGooglePublicEvents(calendar) {
    const timeMin = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1).toISOString();
    const timeMax = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0).toISOString();
    
    const apiKey = 'AIzaSyBNlYH01_9Hc5S1J9vuFmu2nUqBZJNAXxs';
    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendar.calendarId)}/events?key=${apiKey}&timeMin=${timeMin}&timeMax=${timeMax}&orderBy=startTime&singleEvents=true`;
    
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`API Ïò§Î•ò: ${response.status} - ${response.statusText}`);
      }
      
      const data = await response.json();
      
      if (!data.items) {
        throw new Error('Ïù¥Î≤§Ìä∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§');
      }
      
      calendar.events = data.items.map(event => formatGoogleEvent(event, calendar.color));
      addDebugLog(`Íµ¨Í∏Ä Í≥µÍ∞ú Ï∫òÎ¶∞Îçî Î°úÎìú ÏôÑÎ£å: ${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      
    } catch (error) {
      addDebugLog(`Íµ¨Í∏Ä Í≥µÍ∞ú Ï∫òÎ¶∞Îçî Î°úÎìú Ïã§Ìå®: ${error.message}`);
      throw error;
    }
  }
  
  async function loadApiEvents(calendar) {
    const timeMin = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1).toISOString();
    const timeMax = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0).toISOString();
    
    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendar.calendarId)}/events?key=${calendar.apiKey}&timeMin=${timeMin}&timeMax=${timeMax}&orderBy=startTime&singleEvents=true`;
    
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`API Ïò§Î•ò ${response.status}: ${errorData.error?.message || response.statusText}`);
      }
      
      const data = await response.json();
      calendar.events = data.items.map(event => formatGoogleEvent(event, calendar.color));
      addDebugLog(`API Ï∫òÎ¶∞Îçî Î°úÎìú ÏôÑÎ£å: ${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      
    } catch (error) {
      addDebugLog(`API Ï∫òÎ¶∞Îçî Î°úÎìú Ïã§Ìå®: ${error.message}`);
      throw error;
    }
  }
  
  function formatGoogleEvent(event, color) {
    const startDate = event.start.dateTime || event.start.date;
    const endDate = event.end.dateTime || event.end.date;
    const startTime = new Date(startDate);
    const endTime = new Date(endDate);
    
    return {
      title: event.summary || 'Ï†úÎ™© ÏóÜÏùå',
      date: startTime.toISOString().split('T')[0],
      startTime: event.start.dateTime ? 
        startTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }) :
        'Ï¢ÖÏùº',
      endTime: event.end.dateTime ? 
        endTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }) :
        'Ï¢ÖÏùº',
      time: event.start.dateTime ? 
        startTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }) :
        'Ï¢ÖÏùº',
      color: color,
      description: event.description || '',
      location: event.location || ''
    };
  }
  
  function generateSampleEvents() {
    const events = [];
    const today = new Date();
    
    // ÏÉòÌîå Ïù¥Î≤§Ìä∏Îì§ ÏÉùÏÑ±
    const sampleEvents = [
      { title: 'ÌåÄ ÎØ∏ÌåÖ', offset: 1, time: '09:00' },
      { title: 'ÌîÑÎ°úÏ†ùÌä∏ Î∞úÌëú', offset: 3, time: '14:00' },
      { title: 'ÏΩîÎìú Î¶¨Î∑∞', offset: 7, time: '10:30' },
      { title: 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÎØ∏ÌåÖ', offset: -2, time: '16:00' },
      { title: 'Ï¢ÖÏùº ÍµêÏú°', offset: 5, time: 'Ï¢ÖÏùº' }
    ];
    
    sampleEvents.forEach(sample => {
      const eventDate = new Date(today);
      eventDate.setDate(today.getDate() + sample.offset);
      
      events.push({
        title: sample.title,
        date: eventDate.toISOString().split('T')[0],
        time: sample.time,
        startTime: sample.time,
        endTime: sample.time === 'Ï¢ÖÏùº' ? 'Ï¢ÖÏùº' : sample.time,
        description: `${sample.title}Ïóê ÎåÄÌïú ÏÑ§Î™ÖÏûÖÎãàÎã§.`,
        location: 'ÌöåÏùòÏã§ A'
      });
    });
    
    return events;
  }
  
  // ================================================================================
  // iCal ÌååÏã± Ìï®ÏàòÎì§
  // ================================================================================
  
  function parseIcalData(icalText) {
    const events = [];
    const lines = icalText.split(/\r?\n/);
    let currentEvent = null;
    
    addDebugLog(`iCal ÌååÏã± ÏãúÏûë: ${lines.length}Ï§Ñ`);
    
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      
      // Î©ÄÌã∞ÎùºÏù∏ Ï≤òÎ¶¨
      while (i + 1 < lines.length && lines[i + 1].match(/^\s/)) {
        i++;
        line += lines[i].trim();
      }
      
      if (line === 'BEGIN:VEVENT') {
        currentEvent = {};
      } else if (line === 'END:VEVENT' && currentEvent) {
        if (currentEvent.summary && currentEvent.dtstart) {
          const baseEvent = createBaseEvent(currentEvent);
          
          if (currentEvent.rrule) {
            addDebugLog(`Î∞òÎ≥µ ÏùºÏ†ï Î∞úÍ≤¨: ${baseEvent.title}, RRULE: ${currentEvent.rrule}`);
            const viewStart = new Date(currentDate.getFullYear(), currentDate.getMonth() - 2, 1);
            const viewEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 3, 0);
            const expandedEvents = expandRecurringEvent(baseEvent, viewStart, viewEnd);
            events.push(...expandedEvents);
            addDebugLog(`Î∞òÎ≥µ ÏùºÏ†ï ÌôïÏû• ÏôÑÎ£å: ${expandedEvents.length}Í∞ú Ïù∏Ïä§ÌÑ¥Ïä§`);
          } else {
            events.push(baseEvent);
          }
        }
        currentEvent = null;
      } else if (currentEvent) {
        parseEventProperty(line, currentEvent);
      }
    }
    
    addDebugLog(`iCal ÌååÏã± ÏôÑÎ£å: ${events.length}Í∞ú Ïù¥Î≤§Ìä∏ Ï∂îÏ∂ú`);
    return events;
  }
  
  function createBaseEvent(currentEvent) {
    return {
      id: currentEvent.uid || `event_${Date.now()}_${Math.random()}`,
      title: currentEvent.summary,
      date: currentEvent.date,
      start: currentEvent.date + 'T' + (currentEvent.startTime === 'Ï¢ÖÏùº' ? '00:00:00' : currentEvent.startTime + ':00'),
      end: currentEvent.date + 'T' + (currentEvent.endTime === 'Ï¢ÖÏùº' ? '23:59:59' : currentEvent.endTime + ':00'),
      time: currentEvent.time || 'Ï¢ÖÏùº',
      startTime: currentEvent.startTime || currentEvent.time || 'Ï¢ÖÏùº',
      endTime: currentEvent.endTime || currentEvent.time || 'Ï¢ÖÏùº',
      description: currentEvent.description || '',
      location: currentEvent.location || '',
      rrule: currentEvent.rrule,
      exdate: currentEvent.exdate
    };
  }
  
  function parseEventProperty(line, currentEvent) {
    const colonIndex = line.indexOf(':');
    if (colonIndex <= 0) return;
    
    const key = line.substring(0, colonIndex).split(';')[0];
    const value = line.substring(colonIndex + 1);
    
    switch (key) {
      case 'UID':
        currentEvent.uid = value;
        break;
      case 'SUMMARY':
        currentEvent.summary = decodeIcalText(value);
        break;
      case 'DESCRIPTION':
        currentEvent.description = decodeIcalText(value);
        break;
      case 'LOCATION':
        currentEvent.location = decodeIcalText(value);
        break;
      case 'DTSTART':
        const startDate = parseIcalDate(value);
        if (startDate) {
          currentEvent.dtstart = startDate.date;
          currentEvent.date = startDate.date;
          currentEvent.time = startDate.time;
          currentEvent.startTime = startDate.time;
        }
        break;
      case 'DTEND':
        const endDate = parseIcalDate(value);
        if (endDate) {
          currentEvent.endTime = endDate.time;
        }
        break;
      case 'RRULE':
        currentEvent.rrule = value;
        addDebugLog(`RRULE ÌååÏã±Îê®: ${value}`);
        break;
      case 'EXDATE':
        if (!currentEvent.exdate) currentEvent.exdate = [];
        currentEvent.exdate.push(parseIcalDate(value));
        break;
      case 'RECURRENCE-ID':
        currentEvent.recurrenceId = parseIcalDate(value);
        currentEvent.isException = true;
        break;
    }
  }
  
  function decodeIcalText(text) {
    return text
      .replace(/\\n/g, ' ')
      .replace(/\\,/g, ',')
      .replace(/\\;/g, ';')
      .replace(/\\\\/g, '\\')
      .trim();
  }
  
  function parseIcalDate(dateString) {
    try {
      // YYYYMMDD ÌòïÏãù (Ï¢ÖÏùº Ïù¥Î≤§Ìä∏)
      if (/^\d{8}$/.test(dateString)) {
        const year = parseInt(dateString.substring(0, 4));
        const month = parseInt(dateString.substring(4, 6));
        const day = parseInt(dateString.substring(6, 8));
        const date = new Date(year, month - 1, day);
        return {
          date: date.toISOString().split('T')[0],
          time: 'Ï¢ÖÏùº'
        };
      }
      
      // YYYYMMDDTHHMMSS[Z] ÌòïÏãù (ÏãúÍ∞Ñ Ìè¨Ìï®)
      if (/^\d{8}T\d{6}Z?$/.test(dateString)) {
        const year = parseInt(dateString.substring(0, 4));
        const month = parseInt(dateString.substring(4, 6));
        const day = parseInt(dateString.substring(6, 8));
        const hour = parseInt(dateString.substring(9, 11));
        const minute = parseInt(dateString.substring(11, 13));
        
        let date = new Date(year, month - 1, day, hour, minute);
        
        if (dateString.endsWith('Z')) {
          date = new Date(Date.UTC(year, month - 1, day, hour, minute));
        }
        
        return {
          date: date.toISOString().split('T')[0],
          time: date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false })
        };
      }
    } catch (e) {
      addDebugLog(`ÎÇ†Ïßú ÌååÏã± Ïò§Î•ò: ${dateString} - ${e.message}`);
    }
    return null;
  }
  
  // ================================================================================
  // Î∞òÎ≥µ ÏùºÏ†ï Ï≤òÎ¶¨ Ìï®ÏàòÎì§
  // ================================================================================
  
  function expandRecurringEvent(event, viewStart, viewEnd) {
    const occurrences = [];
    const eventStart = new Date(event.start || event.date + 'T00:00:00');
    const eventEnd = new Date(event.end || event.date + 'T23:59:59');
    const eventDuration = eventEnd - eventStart;
    
    const rrule = parseRRule(event.rrule);
    if (!rrule.FREQ) return occurrences;
    
    addDebugLog(`Î∞òÎ≥µ ÏùºÏ†ï ÌôïÏû• ÏãúÏûë: ${event.title}`);
    addDebugLog(`RRULE Î∂ÑÏÑù - FREQ: ${rrule.FREQ}, COUNT: ${rrule.COUNT}, UNTIL: ${rrule.UNTIL}, INTERVAL: ${rrule.INTERVAL}`);
    
    const excludedDates = createExcludedDatesSet(event.exdate);
    let current = new Date(eventStart.getTime());
    const maxOccurrences = rrule.COUNT ? Math.min(parseInt(rrule.COUNT) + 5, 50) : 30;
    let count = 0;
    
    // Î∑∞ ÏãúÏûëÏ†êÏúºÎ°ú Îπ†Î•¥Í≤å Ïù¥Îèô
    current = skipToViewStart(current, viewStart, rrule, maxOccurrences);
    
    // Ïã§Ï†ú Î∞òÎ≥µ ÏùºÏ†ï ÏÉùÏÑ±
    while (current <= viewEnd && count < maxOccurrences) {
      if (current >= viewStart && shouldIncludeOccurrence(current, excludedDates, rrule)) {
        occurrences.push(createOccurrence(event, current, eventDuration, count));
        count++;
      }
      
      current = getNextOccurrence(current, rrule);
      
      if (shouldStopExpansion(current, rrule, count)) break;
    }
    
    addDebugLog(`Î∞òÎ≥µ ÏùºÏ†ï ÌôïÏû• ÏôÑÎ£å: ${occurrences.length}Í∞ú Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±`);
    return occurrences;
  }
  
  function parseRRule(rruleString) {
    const rrule = {};
    const cleanRule = rruleString.replace('RRULE:', '').trim();
    
    cleanRule.split(';').forEach(part => {
      const [key, value] = part.split('=');
      if (key && value) {
        rrule[key.trim()] = value.trim();
      }
    });
    
    return rrule;
  }
  
  function createExcludedDatesSet(exdates) {
    const excludedDates = new Set();
    if (exdates) {
      const dates = Array.isArray(exdates) ? exdates : [exdates];
      dates.forEach(exdate => {
        const excludeDate = new Date(exdate);
        excludedDates.add(excludeDate.toDateString());
      });
    }
    return excludedDates;
  }
  
  function skipToViewStart(current, viewStart, rrule, maxOccurrences) {
    let count = 0;
    while (current < viewStart && count < maxOccurrences) {
      current = getNextOccurrence(current, rrule);
      count++;
    }
    return current;
  }
  
  function shouldIncludeOccurrence(current, excludedDates, rrule) {
    const currentDateString = current.toDateString();
    return !excludedDates.has(currentDateString);
  }
  
  function createOccurrence(event, current, eventDuration, index) {
    const occurrenceStart = new Date(current.getTime());
    const occurrenceEnd = new Date(current.getTime() + eventDuration);
    const eventDate = current.toISOString().split('T')[0];
    
    return {
      ...event,
      id: `${event.id}_${current.getTime()}`,
      date: eventDate,
      start: occurrenceStart.toISOString(),
      end: occurrenceEnd.toISOString(),
      isRecurring: true,
      originalEventId: event.id
    };
  }
  
  function getNextOccurrence(current, rrule) {
    const interval = parseInt(rrule.INTERVAL) || 1;
    
    switch (rrule.FREQ) {
      case 'DAILY':
        current.setDate(current.getDate() + interval);
        break;
      case 'WEEKLY':
        if (rrule.BYDAY) {
          current = getNextWeeklyOccurrence(current, rrule, interval);
        } else {
          current.setDate(current.getDate() + (7 * interval));
        }
        break;
      case 'MONTHLY':
        current.setMonth(current.getMonth() + interval);
        break;
    }
    
    return current;
  }
  
  function getNextWeeklyOccurrence(current, rrule, interval) {
    const dayMap = {'MO': 1, 'TU': 2, 'WE': 3, 'TH': 4, 'FR': 5, 'SA': 6, 'SU': 0};
    const targetDays = rrule.BYDAY.split(',').map(day => dayMap[day.trim()]);
    
    // Îã§Ïùå ÌÉÄÍ≤ü ÏöîÏùº Ï∞æÍ∏∞
    for (let i = 1; i <= 7 * interval; i++) {
      const testDate = new Date(current.getTime());
      testDate.setDate(current.getDate() + i);
      if (targetDays.includes(testDate.getDay()) && i > 7 * (interval - 1)) {
        return testDate;
      }
    }
    
    // Í∏∞Î≥∏ Ï£ºÍ∞Ñ Í∞ÑÍ≤©ÏúºÎ°ú Ïù¥Îèô
    current.setDate(current.getDate() + (7 * interval));
    return current;
  }
  
  function shouldStopExpansion(current, rrule, count) {
    if (rrule.COUNT && count >= parseInt(rrule.COUNT)) {
      addDebugLog(`COUNT Ï†úÌïú ÎèÑÎã¨: ${count}`);
      return true;
    }
    
    if (rrule.UNTIL) {
      const untilDate = parseUntilDate(rrule.UNTIL);
      if (untilDate && current > untilDate) {
        addDebugLog(`UNTIL ÎÇ†Ïßú ÎèÑÎã¨: ${current.toISOString()} > ${untilDate.toISOString()}`);
        return true;
      }
    }
    
    return false;
  }
  
  function parseUntilDate(untilString) {
    try {
      if (untilString.length === 8) {
        // YYYYMMDD ÌòïÏãù
        const year = parseInt(untilString.substring(0, 4));
        const month = parseInt(untilString.substring(4, 6)) - 1;
        const day = parseInt(untilString.substring(6, 8));
        return new Date(year, month, day, 23, 59, 59);
      } else if (untilString.includes('T')) {
        // YYYYMMDDTHHMMSS[Z] ÌòïÏãù
        const parsed = parseIcalDate(untilString);
        if (parsed) {
          return new Date(parsed.date + 'T' + (parsed.time === 'Ï¢ÖÏùº' ? '23:59:59' : parsed.time + ':00'));
        }
      }
    } catch (e) {
      addDebugLog(`UNTIL ÌååÏã± Ïò§Î•ò: ${e.message}`);
    }
    return null;
  }
  
  // ================================================================================
  // Ï∫òÎ¶∞Îçî Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
  // ================================================================================
  
  function updateCalendarColor(calendarId, newColor) {
    const calendar = calendars.find(c => c.id === calendarId);
    if (calendar) {
      calendar.color = newColor;
      renderCalendar();
      saveToStorage();
      addDebugLog(`Ï∫òÎ¶∞Îçî ÏÉâÏÉÅ Î≥ÄÍ≤Ω: ${calendar.name} ‚Üí ${newColor}`);
    }
  }
  
  function updateCalendarName(calendarId, newName) {
    const calendar = calendars.find(c => c.id === calendarId);
    if (calendar && newName.trim()) {
      calendar.name = newName.trim();
      saveToStorage();
      addDebugLog(`Ï∫òÎ¶∞Îçî Ïù¥Î¶Ñ Î≥ÄÍ≤Ω: ${newName}`);
    }
  }
  
  function updateCalendarStatus(calendarId, status, message = '') {
    const calendar = calendars.find(c => c.id === calendarId);
    if (calendar) {
      calendar.status = status;
      calendar.statusMessage = message;
      updateCalendarList();
    }
  }
  
  function toggleCalendarVisibility(calendarId) {
    const calendar = calendars.find(c => c.id === calendarId);
    if (calendar) {
      calendar.visible = !calendar.visible;
      updateCalendarList();
      renderCalendar();
      saveToStorage();
      addDebugLog(`Ï∫òÎ¶∞Îçî Í∞ÄÏãúÏÑ± Î≥ÄÍ≤Ω: ${calendar.name} - ${calendar.visible ? 'Î≥¥ÏûÑ' : 'Ïà®ÍπÄ'}`);
    }
  }
  
  async function reloadCalendar(calendarId) {
    const calendar = calendars.find(c => c.id === calendarId);
    if (!calendar) return;
    
    if (calendar.type === 'sample') {
      calendar.events = generateSampleEvents();
      updateCalendarStatus(calendarId, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      renderCalendar();
      saveToStorage();
      addDebugLog(`ÏÉòÌîå Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å: ${calendar.name}`);
      return;
    }
    
    updateCalendarStatus(calendarId, 'loading', 'ÏÉàÎ°úÍ≥†Ïπ® Ï§ë...');
    addDebugLog(`Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ®: ${calendar.name}`);
    
    try {
      calendar.events = [];
      await loadCalendarEvents(calendar);
      updateCalendarStatus(calendarId, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      renderCalendar();
      saveToStorage();
      addDebugLog(`Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å: ${calendar.name}`);
    } catch (error) {
      updateCalendarStatus(calendarId, 'error', error.message);
      addDebugLog(`Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®: ${calendar.name} - ${error.message}`);
    }
  }
  
  function removeCalendar(calendarId) {
    const calendar = calendars.find(c => c.id === calendarId);
    if (calendar) {
      calendars = calendars.filter(c => c.id !== calendarId);
      
      // Î∑∞Î≥Ñ ÏÑ§Ï†ïÏóêÏÑúÎèÑ Ï†úÍ±∞
      Object.keys(viewCalendarSettings).forEach(view => {
        const index = viewCalendarSettings[view].indexOf(calendarId);
        if (index > -1) {
          viewCalendarSettings[view].splice(index, 1);
        }
      });
      
      updateCalendarList();
      renderCalendar();
      saveToStorage();
      addDebugLog(`Ï∫òÎ¶∞Îçî ÏÇ≠Ï†úÎê®: ${calendar.name}`);
    }
  }
  
  async function refreshAllCalendars() {
    addDebugLog('Î™®Îì† Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏûë');
    
    for (const calendar of calendars) {
      if (calendar.type !== 'sample') {
        updateCalendarStatus(calendar.id, 'loading', 'ÏÉàÎ°úÍ≥†Ïπ® Ï§ë...');
        try {
          calendar.events = [];
          await loadCalendarEvents(calendar);
          updateCalendarStatus(calendar.id, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
        } catch (error) {
          updateCalendarStatus(calendar.id, 'error', error.message);
          addDebugLog(`Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®: ${calendar.name} - ${error.message}`);
        }
      }
    }
    
    renderCalendar();
    saveToStorage();
    addDebugLog('Î™®Îì† Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å');
  }
  
  async function addCalendar() {
    const type = document.getElementById('calendarType').value;
    const name = document.getElementById('calendarName').value.trim();
    const color = document.getElementById('calendarColor').value;
    
    if (!name) {
      alert('Ï∫òÎ¶∞Îçî Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }
    
    const calendarConfig = getCalendarConfig(type);
    if (!calendarConfig) return;
    
    const calendar = createCalendarObject(name, type, color, calendarConfig);
    
    addDebugLog(`Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä ÏãúÏûë: ${name} (${type})`);
    
    calendars.push(calendar);
    updateCalendarList();
    
    try {
      await loadCalendarEvents(calendar);
      updateCalendarStatus(calendar.id, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      addDebugLog(`Ï∫òÎ¶∞Îçî Î°úÎìú ÏÑ±Í≥µ: ${name}, ${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
      renderCalendar();
      saveToStorage();
      
      clearCalendarInputs();
      closeSettings();
    } catch (error) {
      updateCalendarStatus(calendar.id, 'error', error.message);
      addDebugLog(`Ï∫òÎ¶∞Îçî Î°úÎìú Ïã§Ìå®: ${name} - ${error.message}`);
      alert('Ï∫òÎ¶∞ÎçîÎ•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
    }
  }
  
  function getCalendarConfig(type) {
    switch (type) {
      case 'ical':
        const url = document.getElementById('icalUrl').value.trim();
        if (!url || !url.includes('.ics')) {
          alert('Ïò¨Î∞îÎ•∏ iCal ÎßÅÌÅ¨Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return null;
        }
        return { url };
        
      case 'googlePublic':
        const calendarId = document.getElementById('googleCalendarId').value.trim();
        if (!calendarId) {
          alert('Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return null;
        }
        return { calendarId };
        
      case 'api':
        const apiKey = document.getElementById('apiKey').value.trim();
        const apiCalendarId = document.getElementById('calendarId').value.trim() || 'primary';
        if (!apiKey) {
          alert('API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return null;
        }
        return { apiKey, calendarId: apiCalendarId };
        
      default:
        return {};
    }
  }
  
  function createCalendarObject(name, type, color, config) {
    return {
      id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
      name,
      type,
      color,
      visible: true,
      events: [],
      status: 'loading',
      statusMessage: 'Î°úÎî© Ï§ë...',
      ...config
    };
  }
  
  function clearCalendarInputs() {
    const inputs = ['calendarName', 'icalUrl', 'googleCalendarId', 'apiKey', 'calendarId'];
    inputs.forEach(id => {
      const element = document.getElementById(id);
      if (element) element.value = '';
    });
  }
  
  // ================================================================================
  // Ï∫òÎ¶∞Îçî Î¶¨Ïä§Ìä∏ UI Í¥ÄÎ¶¨
  // ================================================================================
  
  function updateCalendarList() {
    if (calendars.length === 0) {
      calendarList.innerHTML = `
        <p style="color: #666; font-size: 12px; text-align: center; padding: 20px;">
          Ïó∞ÎèôÎêú Ï∫òÎ¶∞ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.<br>ÏÉòÌîå Ï∫òÎ¶∞ÎçîÎ•º Ï∂îÍ∞ÄÌïòÍ±∞ÎÇò ÏïÑÎûòÏóêÏÑú Ï∫òÎ¶∞ÎçîÎ•º Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî!
        </p>
      `;
      return;
    }
    
    calendarList.innerHTML = calendars.map(calendar => createCalendarListItem(calendar)).join('');
    updateViewCalendarSettings();
  }
  
  function createCalendarListItem(calendar) {
    const urlDisplay = getUrlDisplay(calendar);
    
    return `
      <div class="calendar-item ${calendar.visible ? 'active' : ''}" data-id="${calendar.id}">
        <input type="color" value="${calendar.color}" 
               onchange="updateCalendarColor('${calendar.id}', this.value)" 
               class="calendar-color-picker" 
               title="Ï∫òÎ¶∞Îçî ÏÉâÏÉÅ Î≥ÄÍ≤Ω">
        <div class="calendar-info">
          <input class="calendar-name" value="${calendar.name}" 
                 onchange="updateCalendarName('${calendar.id}', this.value)"
                 onblur="updateCalendarName('${calendar.id}', this.value)">
          <div class="calendar-url">${urlDisplay}</div>
          <div class="calendar-status ${calendar.status}">${calendar.statusMessage || calendar.status}</div>
        </div>
        <div class="calendar-actions">
          <button class="toggle-btn ${calendar.visible ? 'visible' : 'hidden'}" 
                  onclick="toggleCalendarVisibility('${calendar.id}')" 
                  title="${calendar.visible ? 'Ïà®Í∏∞Í∏∞' : 'Î≥¥Ïù¥Í∏∞'}">
            ${calendar.visible ? 'üëÅÔ∏è' : 'üö´'}
          </button>
          <button class="toggle-btn reload-btn" onclick="reloadCalendar('${calendar.id}')" title="ÏÉàÎ°úÍ≥†Ïπ®">üîÑ</button>
          <button class="toggle-btn remove-btn" onclick="removeCalendar('${calendar.id}')" title="ÏÇ≠Ï†ú">‚ùå</button>
        </div>
      </div>
    `;
  }
  
  function getUrlDisplay(calendar) {
    if (calendar.type === 'sample') return 'ÏÉòÌîå Îç∞Ïù¥ÌÑ∞';
    
    const url = calendar.url || calendar.calendarId || '';
    return url.length > 30 ? url.substring(0, 30) + '...' : url;
  }
  
  // ================================================================================
  // Î∑∞Î≥Ñ Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï Í¥ÄÎ¶¨
  // ================================================================================
  
  function updateViewCalendarSettings() {
    const container = document.getElementById('viewCalendarSettings');
    if (!container) return;
    
    if (calendars.length === 0) {
      container.innerHTML = '<p style="color: #666; font-size: 12px; text-align: center; padding: 10px;">Ïó∞ÎèôÎêú Ï∫òÎ¶∞ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>';
      return;
    }
    
    const views = [
      { key: 'day', name: 'ÏùºÍ∞ÑÎ∑∞' },
      { key: 'week', name: 'Ï£ºÍ∞ÑÎ∑∞' },
      { key: 'month', name: 'ÏõîÍ∞ÑÎ∑∞' }
    ];
    
    container.innerHTML = views.map(view => createViewSection(view)).join('');
  }
  
  function createViewSection(view) {
    return `
      <div class="view-calendar-section">
        <div style="font-weight: bold; margin-bottom: 8px; color: #333;">${view.name}</div>
        <div class="view-calendar-list">
          ${calendars.map(calendar => createViewCalendarItem(view.key, calendar)).join('')}
        </div>
        <div style="margin-top: 8px;">
          <button class="btn btn-secondary" onclick="selectAllViewCalendars('${view.key}')" style="font-size: 11px; padding: 4px 8px;">Ï†ÑÏ≤¥ ÏÑ†ÌÉù</button>
          <button class="btn btn-secondary" onclick="deselectAllViewCalendars('${view.key}')" style="font-size: 11px; padding: 4px 8px; margin-left: 4px;">Ï†ÑÏ≤¥ Ìï¥Ï†ú</button>
        </div>
      </div>
    `;
  }
  
  function createViewCalendarItem(viewKey, calendar) {
    const isChecked = viewCalendarSettings[viewKey].includes(calendar.id);
    
    return `
      <label class="view-calendar-item">
        <input type="checkbox" 
               ${isChecked ? 'checked' : ''}
               onchange="toggleViewCalendar('${viewKey}', '${calendar.id}')"
               style="margin-right: 8px;">
        <span class="calendar-color-dot" style="background-color: ${calendar.color}; width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px;"></span>
        <span>${calendar.name}</span>
      </label>
    `;
  }
  
  function toggleViewCalendar(viewType, calendarId) {
    const index = viewCalendarSettings[viewType].indexOf(calendarId);
    if (index > -1) {
      viewCalendarSettings[viewType].splice(index, 1);
    } else {
      viewCalendarSettings[viewType].push(calendarId);
    }
    saveToStorage();
    renderCalendar();
    addDebugLog(`${viewType}Î∑∞ Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï Î≥ÄÍ≤Ω: ${calendarId}`);
  }
  
  function selectAllViewCalendars(viewType) {
    viewCalendarSettings[viewType] = calendars.map(cal => cal.id);
    updateViewCalendarSettings();
    saveToStorage();
    renderCalendar();
    addDebugLog(`${viewType}Î∑∞ Î™®Îì† Ï∫òÎ¶∞Îçî ÏÑ†ÌÉù`);
  }
  
  function deselectAllViewCalendars(viewType) {
    viewCalendarSettings[viewType] = [];
    updateViewCalendarSettings();
    saveToStorage();
    renderCalendar();
    addDebugLog(`${viewType}Î∑∞ Î™®Îì† Ï∫òÎ¶∞Îçî Ìï¥Ï†ú`);
  }
  
  // ================================================================================
  // Ï∫òÎ¶∞Îçî Î†åÎçîÎßÅ Ìï®ÏàòÎì§
  // ================================================================================
  
  function renderCalendar() {
    switch (currentView) {
      case 'month':
        renderMonthView();
        break;
      case 'week':
        renderWeekView();
        break;
      case 'day':
        renderDayView();
        break;
    }
  }
  
  function getAllEventsForDate(date) {
    const allEvents = [];
    const activeCalendarIds = viewCalendarSettings[currentView];
    const targetDate = date.toISOString().split('T')[0];
  
    calendars.forEach(calendar => {
      if (!calendar.visible || !calendar.events) return;
      if (activeCalendarIds.length > 0 && !activeCalendarIds.includes(calendar.id)) return;
  
      const events = calendar.events.filter(event => event.date === targetDate);
      events.forEach(event => {
        allEvents.push({
          ...event,
          color: calendar.color,
          calendarName: calendar.name
        });
      });
    });
    
    return removeDuplicateEvents(allEvents);
  }
  
  function removeDuplicateEvents(events) {
    const seen = new Set();
    return events.filter(event => {
      const key = `${event.title}_${event.date}_${event.startTime}_${event.endTime}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  
  function renderMonthView() {
    const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const startDate = new Date(firstDay);
    const mondayOffset = (firstDay.getDay() + 6) % 7;
    startDate.setDate(startDate.getDate() - mondayOffset);
    
    const grid = document.createElement('div');
    grid.className = 'calendar-grid month-view';
    
    // ÏöîÏùº Ìó§Îçî
    weekdays.forEach(day => {
      const header = document.createElement('div');
      header.className = 'week-header';
      header.textContent = day;
      grid.appendChild(header);
    });
    
    // ÎÇ†Ïßú ÏÖÄ
    const today = new Date();
    for (let i = 0; i < 42; i++) {
      const cellDate = new Date(startDate);
      cellDate.setDate(startDate.getDate() + i);
      
      const cell = createMonthCell(cellDate, today);
      grid.appendChild(cell);
    }
    
    calendarContent.innerHTML = '';
    calendarContent.appendChild(grid);
  }
  
  function createMonthCell(cellDate, today) {
    const cell = document.createElement('div');
    cell.className = 'calendar-day';
    
    if (cellDate.getMonth() !== currentDate.getMonth()) {
      cell.classList.add('other-month');
    }
    
    if (cellDate.toDateString() === today.toDateString()) {
      cell.classList.add('today');
    }
    
    const dayNumber = document.createElement('div');
    dayNumber.className = 'day-number';
    dayNumber.textContent = cellDate.getDate();
    cell.appendChild(dayNumber);
    
    const dayEvents = getAllEventsForDate(cellDate);
    dayEvents.slice(0, 4).forEach(event => {
      const eventDiv = createEventDiv(event, 'month');
      cell.appendChild(eventDiv);
    });
    
    if (dayEvents.length > 4) {
      const moreDiv = document.createElement('div');
      moreDiv.className = 'event';
      moreDiv.style.backgroundColor = '#999';
      moreDiv.textContent = `+${dayEvents.length - 4}Í∞ú Îçî`;
      cell.appendChild(moreDiv);
    }
    
    return cell;
  }
  
  function createEventDiv(event, viewType) {
    const eventDiv = document.createElement('div');
    eventDiv.className = viewType === 'month' ? 'event' : 
                       event.time === 'Ï¢ÖÏùº' ? 'all-day-event' : 'time-event';
    
    eventDiv.style.backgroundColor = event.color;
    eventDiv.style.color = viewType === 'month' || event.time === 'Ï¢ÖÏùº' ? '#333' : 'white';
    eventDiv.textContent = event.title;
    
    const tooltipText = createTooltipText(event);
    eventDiv.title = tooltipText;
    
    // Í∏∞Ï°¥ ÌÅ¨Í∏∞ Ïú†ÏßÄ
    if (viewType === 'month') {
      eventDiv.style.padding = '4px 8px';
      eventDiv.style.fontSize = '0.6em';
    } else if (event.time === 'Ï¢ÖÏùº') {
      eventDiv.style.padding = '4px 8px';
      eventDiv.style.fontSize = '0.6em';
    } else {
      eventDiv.style.padding = '2px 6px';
      eventDiv.style.fontSize = '0.6em';
    }
    
    eventDiv.style.borderRadius = '6px';
    eventDiv.style.margin = '2px';
    eventDiv.style.overflow = 'visible';
    eventDiv.style.textOverflow = 'clip';
    eventDiv.style.whiteSpace = 'normal';
    eventDiv.style.wordWrap = 'break-word';
    eventDiv.style.wordBreak = 'break-word';
    eventDiv.style.lineHeight = '1.2';
    eventDiv.style.minHeight = '20px';
    
    return eventDiv;
  }
  
  function createTooltipText(event) {
    let tooltip = `${event.title}\nÏãúÍ∞Ñ: ${event.time}\nÏ∫òÎ¶∞Îçî: ${event.calendarName}`;
    if (event.location) tooltip += `\nÏúÑÏπò: ${event.location}`;
    if (event.description) tooltip += `\nÏÑ§Î™Ö: ${event.description}`;
    return tooltip;
  }
  
  // ================================================================================
  // Ï£ºÍ∞Ñ/ÏùºÍ∞Ñ Î∑∞ Î†åÎçîÎßÅ (ÏãúÍ∞Ñ Í∏∞Î∞ò)
  // ================================================================================
  
  function renderWeekView() {
    const startOfWeek = new Date(currentDate);
    startOfWeek.setDate(currentDate.getDate() - currentDate.getDay());
  
    const container = createTimeBasedContainer();
    const grid = createTimeGrid(7);
    
    // Ìó§Îçî Ï∂îÍ∞Ä
    addTimeHeader(grid);
    addWeekHeaders(grid, startOfWeek);
    
    // ÏãúÍ∞Ñ Ïä¨Î°ØÍ≥º Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
    const dayCells = createTimeSlots(grid, 7);
    renderWeekEvents(startOfWeek, dayCells);
    
    container.appendChild(grid);
    calendarContent.innerHTML = '';
    calendarContent.appendChild(container);
  }
  
  function renderDayView() {
    const container = createTimeBasedContainer();
    const grid = createTimeGrid(1);
    
    // Ìó§Îçî Ï∂îÍ∞Ä
    addTimeHeader(grid);
    addDayHeader(grid);
    
    // ÏãúÍ∞Ñ Ïä¨Î°ØÍ≥º Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
    const dayCells = createTimeSlots(grid, 1);
    renderDayEvents(dayCells);
    
    container.appendChild(grid);
    calendarContent.innerHTML = '';
    calendarContent.appendChild(container);
  }
  
  function createTimeBasedContainer() {
    const container = document.createElement('div');
    container.style.padding = '20px';
    container.style.height = '600px';
    container.style.overflow = 'auto';
    return container;
  }
  
  function createTimeGrid(dayCount) {
    const grid = document.createElement('div');
    grid.className = `time-based-view ${currentView}-view`;
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = `80px repeat(${dayCount}, 1fr)`;
    grid.style.gridTemplateRows = `35px repeat(${SLOT_COUNT}, 25px)`;
    grid.style.gap = '0';
    grid.style.height = currentView === 'day' ? '550px' : '500px';
    return grid;
  }
  
  function addTimeHeader(grid) {
    const timeHeader = document.createElement('div');
    timeHeader.className = 'week-header';
    timeHeader.textContent = 'ÏãúÍ∞Ñ';
    timeHeader.style.gridRow = '1';
    timeHeader.style.gridColumn = '1';
    addCellStyles(timeHeader, '#f5f5f5');
    grid.appendChild(timeHeader);
  }
  
  function addWeekHeaders(grid, startOfWeek) {
    for (let i = 0; i < 7; i++) {
      const date = new Date(startOfWeek);
      date.setDate(startOfWeek.getDate() + i);
      
      const header = createWeekHeader(date, i + 2);
      grid.appendChild(header);
    }
  }
  
  function addDayHeader(grid) {
    const dayHeader = document.createElement('div');
    dayHeader.className = 'week-header';
    
    const today = new Date();
    const bgColor = currentDate.toDateString() === today.toDateString() ? accentColor : '#f5f5f5';
    
    const dayName = document.createElement('div');
    const options = { month: 'short', day: 'numeric', weekday: 'short' };
    dayName.textContent = currentDate.toLocaleDateString('ko-KR', options);
    dayHeader.appendChild(dayName);
    
    dayHeader.style.gridRow = '1';
    dayHeader.style.gridColumn = '2';
    addCellStyles(dayHeader, bgColor);
    grid.appendChild(dayHeader);
  }
  
  function createWeekHeader(date, column) {
    const header = document.createElement('div');
    header.className = 'week-header';
    header.style.gridRow = '1';
    header.style.gridColumn = column.toString();
    
    const bgColor = date.toDateString() === (new Date()).toDateString() ? accentColor : '#f5f5f5';
    addCellStyles(header, bgColor);
    
    const dayName = document.createElement('div');
    dayName.textContent = weekdays[date.getDay()];
    dayName.style.fontWeight = 'bold';
    header.appendChild(dayName);
    
    const dayNumber = document.createElement('div');
    dayNumber.textContent = date.getDate();
    dayNumber.style.fontSize = '0.9em';
    dayNumber.style.color = '#666';
    header.appendChild(dayNumber);
    
    return header;
  }
  
  function createTimeSlots(grid, dayCount) {
    const dayCells = Array.from({length: dayCount}, () => []);
    
    for (let slotIndex = 0; slotIndex < SLOT_COUNT; slotIndex++) {
      const displayHour = getDisplayHour(slotIndex);
      
      // ÏãúÍ∞Ñ ÎùºÎ≤®
      const timeSlot = createTimeSlot(slotIndex, displayHour);
      grid.appendChild(timeSlot);
      
      // Í∞Å ÏöîÏùºÎ≥Ñ Í∏∞Î≥∏ Î∞∞Í≤Ω
      for (let day = 0; day < dayCount; day++) {
        const cell = createDayCell(slotIndex, day, dayCount);
        dayCells[day][slotIndex] = cell;
        grid.appendChild(cell);
      }
    }
    
    return dayCells;
  }
  
  function createTimeSlot(slotIndex, displayHour) {
    const timeSlot = document.createElement('div');
    timeSlot.className = 'time-slot';
    timeSlot.textContent = `${displayHour.toString().padStart(2, '0')}:00`;
    timeSlot.style.gridRow = `${slotIndex + 2}`;
    timeSlot.style.gridColumn = '1';
    addCellStyles(timeSlot, '#fafafa');
    timeSlot.style.fontSize = '0.8em';
    return timeSlot;
  }
  
  function createDayCell(slotIndex, day, dayCount) {
    const cell = document.createElement('div');
    cell.className = 'day-cell';
    cell.dataset.day = day;
    cell.dataset.slot = slotIndex;
    cell.style.gridRow = `${slotIndex + 2}`;
    cell.style.gridColumn = `${day + 2}`;
    cell.style.position = 'relative';
    
    const bgColor = slotIndex >= 18 ? '#f9f9f9' : 'white';
    addCellStyles(cell, bgColor);
    
    return cell;
  }
  
  function addCellStyles(element, backgroundColor) {
    element.style.border = '1px solid #e0e0e0';
    element.style.padding = '8px';
    element.style.textAlign = 'center';
    element.style.backgroundColor = backgroundColor;
  }
  
  function renderWeekEvents(startOfWeek, dayCells) {
    for (let day = 0; day < 7; day++) {
      const date = new Date(startOfWeek);
      date.setDate(startOfWeek.getDate() + day);
      
      const dayEvents = getAllEventsForDate(date);
      renderDayEvents(dayCells[day], dayEvents);
    }
  }
  
  function renderDayEvents(dayCells, dayEvents = null) {
    if (!dayEvents) {
      dayEvents = getAllEventsForDate(currentDate);
    }
    
    const eventCounts = Array(SLOT_COUNT).fill(0);
    const slotEventDivs = Array(SLOT_COUNT).fill().map(() => []);
    
    dayEvents.forEach(event => {
      const splitEvents = splitCrossDayEvent(event);
      
      splitEvents.forEach(splitEvent => {
        if (splitEvent.isNextDay) return;
        
        if (splitEvent.time === 'Ï¢ÖÏùº') {
          renderAllDayEvent(splitEvent, dayCells[0]);
        } else {
          renderTimeEvent(splitEvent, dayCells, eventCounts, slotEventDivs);
        }
      });
    });
    
    // Í∞Å Ïä¨Î°ØÏùò Ïù¥Î≤§Ìä∏Îì§Ïóê Ï†ÅÏ†àÌïú Î™®ÏÑúÎ¶¨ Ï≤òÎ¶¨ Ï†ÅÏö©
    for (let slot = 0; slot < SLOT_COUNT; slot++) {
      if (slotEventDivs[slot] && slotEventDivs[slot].length > 0) {
        applyRoundedCorners(slotEventDivs[slot]);
      }
    }
  }
  
  function renderAllDayEvent(event, cell) {
    if (!cell) return;
    
    const eventDiv = createEventDiv(event, 'time');
    eventDiv.style.position = 'absolute';
    eventDiv.style.top = '2px';
    eventDiv.style.left = '2px';
    eventDiv.style.right = '2px';
    eventDiv.style.height = 'calc(100% - 4px)';
    eventDiv.style.whiteSpace = 'normal';
    
    cell.appendChild(eventDiv);
  }
  
  function renderTimeEvent(event, dayCells, eventCounts, slotEventDivs) {
    const startHour = getEventHour(event.startTime);
    const endHour = getEventHour(event.endTime);
    const startMinute = getEventMinute(event.startTime);
    const endMinute = getEventMinute(event.endTime);
  
    const startPosition = getExactSlotPosition(startHour, startMinute);
    const endPosition = getExactSlotPosition(endHour, endMinute);
    const clampedEndPosition = Math.min(endPosition, SLOT_COUNT);
    const startSlot = Math.floor(startPosition);
    
    if (!dayCells[startSlot]) return;
    
    const currentEventIndex = eventCounts[startSlot];
    eventCounts[startSlot]++;
  
    const eventDiv = createEventDiv(event, 'time');
    eventDiv.style.position = 'absolute';
    eventDiv.style.boxSizing = 'border-box';
    eventDiv.style.zIndex = 100 + currentEventIndex;
    
    // Ï†ïÌôïÌïú ÏúÑÏπòÏôÄ ÎÜíÏù¥ Í≥ÑÏÇ∞
    const cellHeight = 25;
    const topOffset = (startPosition - startSlot) * cellHeight;
    const height = (clampedEndPosition - startPosition) * cellHeight;
    
    eventDiv.style.top = `${topOffset}px`;
    eventDiv.style.height = `${Math.max(height, 20)}px`;
    
    // Í≤πÏπòÎäî Ïù¥Î≤§Ìä∏Îì§ÏùÑ Í∑∏Î¶¨ÎìúÏóê Îî± ÎßûÍ≤å Î∞∞Ïπò
    const totalEvents = Math.max(eventCounts[startSlot], 1);
    const eventWidth = Math.floor(100 / totalEvents);
    const leftPosition = currentEventIndex * eventWidth;
    
    eventDiv.style.left = `${leftPosition}%`;
    eventDiv.style.width = `${eventWidth}%`;
    
    dayCells[startSlot].appendChild(eventDiv);
    if (slotEventDivs[startSlot]) {
      slotEventDivs[startSlot].push(eventDiv);
    }
  }
  
  // ================================================================================
  // ÏãúÍ∞Ñ Í¥ÄÎ†® Ìó¨Ìçº Ìï®ÏàòÎì§
  // ================================================================================
  
  function getDisplayHour(slotIndex) {
    return (SLOT_START_HOUR + slotIndex) % 24;
  }
  
  function getSlotIndex(hour) {
    if (hour >= SLOT_START_HOUR) {
      return hour - SLOT_START_HOUR;
    } else {
      return hour + (24 - SLOT_START_HOUR);
    }
  }
  
  function getExactSlotPosition(hour, minute) {
    const slotIndex = getSlotIndex(hour);
    return slotIndex + (minute / 60);
  }
  
  function getEventHour(timeString) {
    if (timeString === 'Ï¢ÖÏùº') return SLOT_START_HOUR;
    const parts = timeString.split(':');
    return parseInt(parts[0], 10) || 0;
  }
  
  function getEventMinute(timeString) {
    if (timeString === 'Ï¢ÖÏùº') return 0;
    const parts = timeString.split(':');
    return parseInt(parts[1], 10) || 0;
  }
  
  function splitCrossDayEvent(event) {
    if (event.time === 'Ï¢ÖÏùº') return [event];
    
    const startHour = getEventHour(event.startTime);
    
    // 0-5Ïãú Ïù¥Î≤§Ìä∏Îßå Îã§ÏùåÎÇ†Î°ú Ï≤òÎ¶¨ (ÏõêÎûò ÏùòÎèÑÎåÄÎ°ú)
    // 6Ïãú Ïù¥ÌõÑ Ïù¥Î≤§Ìä∏Îäî Î™®Îëê ÎãπÏùºÏóê ÌëúÏãú
    return [event];
  }
  
  function applyRoundedCorners(eventsInSlot) {
    if (eventsInSlot.length === 0) return;
  
    eventsInSlot.forEach((eventDiv, index) => {
      // Î™®Îì† Ïù¥Î≤§Ìä∏Ïóê Í∏∞Î≥∏ Îë•Í∑º Î™®ÏÑúÎ¶¨ Ï†ÅÏö©
      eventDiv.style.borderRadius = '6px';
      
      // Ï∂îÍ∞Ä: Í∑∏Î¶ºÏûê Ìö®Í≥ºÎ°ú ÏûÖÏ≤¥Í∞ê Î∂ÄÏó¨
      eventDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
    });
  }
  
  // ================================================================================
  // Ï†ÄÏû•/Î∂àÎü¨Ïò§Í∏∞ Ìï®ÏàòÎì§
  // ================================================================================
  
  function saveToStorage() {
    try {
      const data = {
        view: currentView,
        currentDate: currentDate.toISOString(),
        accentColor: accentColor,
        accentHoverColor: accentHoverColor,
        viewCalendarSettings: viewCalendarSettings,
        calendars: calendars.map(cal => ({
          ...cal,
          events: cal.events || []
        }))
      };
      
      localStorage.setItem('multiCalendarData', JSON.stringify(data));
      addDebugLog('ÏÑ§Ï†ïÏù¥ localStorageÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.');
    } catch (e) {
      addDebugLog(`Ï†ÄÏû• Ïã§Ìå®: ${e.message}`);
    }
  }
  
  function loadFromStorage() {
    try {
      const data = localStorage.getItem('multiCalendarData');
      if (!data) return;
      
      const parsed = JSON.parse(data);
      
      // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï Î∞è Îç∞Ïù¥ÌÑ∞ Î≥µÏõê
      currentView = parsed.view || 'day';
      if (parsed.currentDate) {
        currentDate = new Date(parsed.currentDate);
      }
      accentColor = parsed.accentColor || '#D1D1D1';
      accentHoverColor = parsed.accentHoverColor || darkenColor(accentColor, 15);
      viewCalendarSettings = parsed.viewCalendarSettings || { day: [], week: [], month: [] };
      calendars = parsed.calendars || [];
      
      // UI Î≥µÏõê
      document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(currentView + 'Btn').classList.add('active');
      
      // Ï†ÄÏû•Îêú Ï∫òÎ¶∞ÎçîÎì§Ïùò Ïù¥Î≤§Ìä∏ Îã§Ïãú Î°úÎìú
      calendars.forEach(async (calendar) => {
        if (calendar.type !== 'sample' && (!calendar.events || calendar.events.length === 0)) {
          updateCalendarStatus(calendar.id, 'loading', 'Î°úÎî© Ï§ë...');
          try {
            await loadCalendarEvents(calendar);
            updateCalendarStatus(calendar.id, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
          } catch (error) {
            updateCalendarStatus(calendar.id, 'error', error.message);
            addDebugLog(`Ï†ÄÏû•Îêú Ï∫òÎ¶∞Îçî Î°úÎìú Ïã§Ìå®: ${calendar.name} - ${error.message}`);
          }
        } else {
          updateCalendarStatus(calendar.id, 'success', `${(calendar.events || []).length}Í∞ú Ïù¥Î≤§Ìä∏`);
        }
      });
      
      addDebugLog('ÏÑ§Ï†ïÏù¥ localStorageÏóêÏÑú Î≥µÏõêÎêòÏóàÏäµÎãàÎã§.');
    } catch (e) {
      addDebugLog(`Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®: ${e.message}`);
    }
  }
  
  // ================================================================================
  // ÏÑ§Ï†ï Î∞±ÏóÖ/Î≥µÏõê Ìï®ÏàòÎì§
  // ================================================================================
  
  function exportCalendarSettings() {
    try {
      const exportData = {
        version: '1.0',
        exportDate: new Date().toISOString(),
        view: currentView,
        currentDate: currentDate.toISOString(),
        accentColor: accentColor,
        accentHoverColor: accentHoverColor,
        viewCalendarSettings: viewCalendarSettings,
        calendars: calendars.map(cal => ({
          id: cal.id,
          name: cal.name,
          type: cal.type,
          color: cal.color,
          visible: cal.visible,
          url: cal.url,
          calendarId: cal.calendarId,
          apiKey: cal.apiKey,
          status: cal.status,
          statusMessage: cal.statusMessage
        }))
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const link = document.createElement('a');
      link.href = URL.createObjectURL(dataBlob);
      link.download = `Ï∫òÎ¶∞ÎçîÏÑ§Ï†ï_${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      
      addDebugLog(`Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å: ${calendars.length}Í∞ú Ï∫òÎ¶∞Îçî`);
      alert('Ï∫òÎ¶∞Îçî ÏÑ§Ï†ïÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§.');
      
    } catch (error) {
      addDebugLog(`ÏÑ§Ï†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: ${error.message}`);
      alert('ÏÑ§Ï†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
    }
  }
  
  async function importCalendarSettings(fileInput) {
    const file = fileInput.files[0];
    if (!file) return;
    
    try {
      const text = await file.text();
      const importData = JSON.parse(text);
      
      if (!importData.version) {
        throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏÑ§Ï†ï ÌååÏùºÏûÖÎãàÎã§.');
      }
      
      addDebugLog(`ÏÑ§Ï†ï ÌååÏùº Í∞ÄÏ†∏Ïò§Í∏∞ ÏãúÏûë: ${importData.calendars?.length || 0}Í∞ú Ï∫òÎ¶∞Îçî`);
      
      await restoreSettingsFromImport(importData);
      
      addDebugLog('Ï∫òÎ¶∞Îçî ÏÑ§Ï†ï Í∞ÄÏ†∏Ïò§Í∏∞ ÏôÑÎ£å');
      alert(`Ï∫òÎ¶∞Îçî ÏÑ§Ï†ïÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.\nÎ≥µÏõêÎêú Ï∫òÎ¶∞Îçî: ${importData.calendars?.length || 0}Í∞ú`);
      
    } catch (error) {
      addDebugLog(`ÏÑ§Ï†ï Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: ${error.message}`);
      alert('ÏÑ§Ï†ï ÌååÏùºÏùÑ ÏùΩÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
    }
    
    fileInput.value = '';
  }
  
  async function restoreSettingsFromImport(importData) {
    // Í∏∞Ï°¥ Ï∫òÎ¶∞Îçî Î∞±ÏóÖ (sample Ï†úÏô∏)
    const backupCalendars = calendars.filter(cal => cal.type === 'sample');
    
    // ÏÑ§Ï†ï Î≥µÏõê
    currentView = importData.view || 'day';
    if (importData.currentDate) {
      currentDate = new Date(importData.currentDate);
    }
    if (importData.accentColor) {
      setAccentColor(importData.accentColor);
    }
    if (importData.viewCalendarSettings) {
      viewCalendarSettings = importData.viewCalendarSettings;
    }
    
    // Ï∫òÎ¶∞Îçî Î≥µÏõê Î∞è Ïù¥Î≤§Ìä∏ Î°úÎìú
    calendars = [...backupCalendars];
    
    if (importData.calendars && Array.isArray(importData.calendars)) {
      for (const calData of importData.calendars) {
        if (calData.type === 'sample') continue;
        
        const calendar = {
          id: calData.id || Date.now().toString() + Math.random(),
          name: calData.name || 'Ïù¥Î¶Ñ ÏóÜÏùå',
          type: calData.type,
          color: calData.color || '#D1D1D1',
          visible: calData.visible !== false,
          url: calData.url,
          calendarId: calData.calendarId,
          apiKey: calData.apiKey,
          events: [],
          status: 'loading',
          statusMessage: 'Î∂àÎü¨Ïò§Îäî Ï§ë...'
        };
        
        calendars.push(calendar);
        updateCalendarStatus(calendar.id, 'loading', 'Î∂àÎü¨Ïò§Îäî Ï§ë...');
        
        try {
          await loadCalendarEvents(calendar);
          updateCalendarStatus(calendar.id, 'success', `${calendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
          addDebugLog(`Ï∫òÎ¶∞Îçî Î≥µÏõê ÏÑ±Í≥µ: ${calendar.name}`);
        } catch (error) {
          updateCalendarStatus(calendar.id, 'error', error.message);
          addDebugLog(`Ï∫òÎ¶∞Îçî Î≥µÏõê Ïã§Ìå®: ${calendar.name} - ${error.message}`);
        }
      }
    }
    
    // UI ÏóÖÎç∞Ïù¥Ìä∏
    document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(currentView + 'Btn').classList.add('active');
    
    updateCurrentDateDisplay();
    updateCalendarList();
    renderCalendar();
    saveToStorage();
  }
  
  // ================================================================================
  // ÌäπÏàò Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä Ìï®ÏàòÎì§
  // ================================================================================
  
  function addKoreanHolidays() {
    const holidayCalendar = {
      id: 'korean-holidays-' + Date.now(),
      name: 'ÌïúÍµ≠ Í≥µÌú¥Ïùº',
      type: 'googlePublic',
      color: '#ea4335',
      visible: true,
      calendarId: 'ko.south_korea#holiday@group.v.calendar.google.com',
      events: [],
      status: 'loading',
      statusMessage: 'Î°úÎî© Ï§ë...'
    };
    
    calendars.push(holidayCalendar);
    updateCalendarList();
    
    loadCalendarEvents(holidayCalendar)
      .then(() => {
        updateCalendarStatus(holidayCalendar.id, 'success', `${holidayCalendar.events.length}Í∞ú Ïù¥Î≤§Ìä∏`);
        renderCalendar();
        saveToStorage();
        addDebugLog('ÌïúÍµ≠ Í≥µÌú¥Ïùº Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä ÏôÑÎ£å');
      })
      .catch(error => {
        updateCalendarStatus(holidayCalendar.id, 'error', error.message);
        addDebugLog(`ÌïúÍµ≠ Í≥µÌú¥Ïùº Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä Ïã§Ìå®: ${error.message}`);
      });
  }
  
  function addSampleCalendar() {
    const sampleCalendar = {
      id: 'sample-' + Date.now(),
      name: 'ÏÉòÌîå Ï∫òÎ¶∞Îçî',
      type: 'sample',
      color: calendarColors[calendars.length % calendarColors.length],
      visible: true,
      events: generateSampleEvents(),
      status: 'success',
      statusMessage: 'ÏÉòÌîå Îç∞Ïù¥ÌÑ∞'
    };
    
    calendars.push(sampleCalendar);
    updateCalendarList();
    renderCalendar();
    saveToStorage();
    addDebugLog('ÏÉòÌîå Ï∫òÎ¶∞ÎçîÍ∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.');
  }
  
  // ================================================================================
  // ÎîîÎ≤ÑÍ∑∏ ÎèÑÍµ¨ Î∞è Ï¥àÍ∏∞Ìôî
  // ================================================================================
  
  // ÎîîÎ≤ÑÍ∑∏Ïö© Ìï®ÏàòÎì§
  window.debugCalendar = {
    showCalendars: () => console.table(calendars),
    showEvents: (calendarId) => {
      const calendar = calendars.find(c => c.id === calendarId || c.name === calendarId);
      if (calendar) {
        console.table(calendar.events);
      } else {
        console.log('Ï∫òÎ¶∞ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    },
    clearStorage: () => {
      localStorage.removeItem('multiCalendarData');
      location.reload();
    },
    addKoreanHolidays: addKoreanHolidays,
    addSampleCalendar: addSampleCalendar
  };
  
  // ÎèÑÏõÄÎßê ÌëúÏãú
  console.log('%cÎ©ÄÌã∞ Ï∫òÎ¶∞Îçî Î∑∞Ïñ¥ ÎîîÎ≤ÑÍ∑∏ ÎèÑÍµ¨%c\n' +
    'debugCalendar.showCalendars() - Î™®Îì† Ï∫òÎ¶∞Îçî Ï†ïÎ≥¥ ÌëúÏãú\n' +
    'debugCalendar.showEvents(Ï∫òÎ¶∞ÎçîID) - ÌäπÏ†ï Ï∫òÎ¶∞ÎçîÏùò Ïù¥Î≤§Ìä∏ ÌëúÏãú\n' +
    'debugCalendar.clearStorage() - Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Î∞è ÏÉàÎ°úÍ≥†Ïπ®\n' +
    'debugCalendar.addKoreanHolidays() - ÌïúÍµ≠ Í≥µÌú¥Ïùº Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä\n' +
    'debugCalendar.addSampleCalendar() - ÏÉòÌîå Ï∫òÎ¶∞Îçî Ï∂îÍ∞Ä', 
    'color: #D1D1D1; font-weight: bold; font-size: 14px;', 
    'color: #333; font-size: 12px;');
  
  // Ï¥àÍ∏∞Ìôî Ïã§Ìñâ
  init();
  </script>
</body>
</html>
